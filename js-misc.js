Некоторые другие возможности

Типы данных: [
    [Class]
], instanceof и утки
Полиморфная функция formatDate
// важность: 5
// Напишите функцию formatDate(date), которая возвращает дату в формате dd.mm.yy.

// Ее первый аргумент должен содержать дату в одном из видов:

// Как объект Date.
// Как строку, например yyyy-mm-dd или другую в стандартном формате даты.
// Как число секунд с 01.01.1970.
// Как массив [гггг, мм, дд], месяц начинается с нуля
// Для этого вам понадобится определить тип данных аргумента и, при необходимости, 
// преобразовать входные данные в нужный формат.


function formatDate(date) {
    //взяв рішення яке пропонували в статті, а вони в розвязку на мою думку пішли навколо
    var type = {}.toString.call(date).slice(8, -1);
    var point = '.'
    this.format = function(str) {
        return str.substr(8, 2) + point + str.substr(5, 2) + point + str.substr(2, 2);
    }

    if (type == 'String') {
        var res = date.substr(8) + point + date.substr(5, 2) + point + date.substr(2, 2);
    } else if (type == 'Number') {
        var str = new Date(date).toISOString();
        res = this.format(str);
    } else if (type == 'Array') {
        var str = new Date(date[0], date[1], date[2]).toISOString();
        res = this.format(str);
    } else if (type == 'Date') { //str уже має неправильну дату. toISOString() - це барахлить?
        var str = new Date(Date.parse(date)).toISOString();
        console.log(res);
        res = this.format(str);
    }
    return res;
}

console.log(formatDate('2011-10-02')); // 02.10.11
console.log(formatDate(1234567890)); // 14.02.09
//тут проблемка в останніх двох варіантах віднімає один день від дати, не можу зхрозуміти чому
console.log(formatDate([2014, 2, 13])); // 01.01.14
console.log(formatDate(new Date(2014, 5, 11))); // 01.01.14

______________________________________________________________________

Формат JSON, метод toJSON

Превратите объект в JSON
// важность: 3
// Превратите объект leader из примера ниже в JSON:

// После этого прочитайте получившуюся строку обратно в объект.// 


var leader = {
    name: "Василий Иванович",
    age: 35
};

var line = JSON.stringify(leader);
console.log(line);

var obj = JSON.parse(line);
console.log(obj);
______________________________________________________________________

Превратите объекты со ссылками в JSON
// важность: 3
// Превратите объект team из примера ниже в JSON:
// Может ли это сделать прямой вызов JSON.stringify(team)? Если нет, то почему?
// Какой подход вы бы предложили для чтения и восстановления таких объектов?
// решение

var leader = {
    name: "Василий Иванович"
};

var soldier = {
    name: "Петька"
};

// эти объекты ссылаются друг на друга!
leader.soldier = soldier;
soldier.leader = leader;

var team = [leader, soldier];

//   var res = JSON.stringify(team);
//   //error
//   console.log(res);
//якось так. не все вирішує, але щось в тому є. ще в відповідь не дивився. може щось порекомендуєш то перероблю
//тоді подивлюсь
function serial(arr) {
    internalArr = [];
    var result;
    arr.forEach(function(item, i) {
        internalArr.push(JSON.stringify(item, ["name"]));
    })
    return JSON.stringify(internalArr);
}

console.log(serial(team));
//виводить таке ["{"name":"Василий Иванович"}", "{"name":"Петька"}"]

var parce = serial(team);
console.log(JSON.parse(parce));

______________________________________________________________________
setTimeout и setInterval

Вывод чисел каждые 100 мс
// важность: 5
// Напишите функцию printNumbersInterval(), которая последовательно выводит в консоль числа от 1 до 20,
//  с интервалом между числами 100 мс. То есть, весь вывод должен занимать 2000 мс, в течение которых
//   каждые 100 мс в консоли появляется очередное число.
//P.S. Функция должна использовать setInterval.

//це мій код - тут щось дивне відбувається - поясни
function printNumbersInterval() {

    //взагалі  - через цикл можна вирішити це питання?

    var start = setInterval(function() {
        for (i = 0; i < 20; i++) {
            console.log(i);
        }
        if (i == 20)
            clearInterval(start);
    }, 100);
}

printNumbersInterval();

//а це їхній
function printNumbersInterval() {
    var i = 1;
    var timerId = setInterval(function() {
        console.log(i);
        if (i == 20) clearInterval(timerId); //тут можна очищувати змінну з середини її самої????
        i++;
    }, 100);
}

// вызов
printNumbersInterval();

______________________________________________________________________

Вывод чисел каждые 100 мс, через setTimeout
// важность: 5
// Сделайте то же самое, что в задаче Вывод чисел каждые 100 мс, но с использованием рекурсивного
// setTimeout вместо setInterval.

function rander(value) {
    console.log(value);
}
//зробив по анології з попереднім
function printNumbersInterval() {
    //початкове значення
    var i = 1;
    //в змінну записується для того щоб можна було очистити???????
    var iter = setTimeout(function run() {
        //вивід 
        rander(i);
        //яким чином тут не виводиться ще раз число???? тут мало б зависати. тому що функція
        //малаби без виходу з умови крутитись тут вічно.????не зовсім розумію
        iter = setTimeout(run, 100);
        if (i == 20) clearTimeout(iter);
        i++;
    }, 100);

}

// вызов
printNumbersInterval();

______________________________________________________________________

Функция - задержка
    // важность: 5
    // Напишите функцию delay(f, ms), которая возвращает обёртку вокруг f, задерживающую вызов на ms миллисекунд.

// Упрощённо можно сказать, что delay возвращает "задержанный на ms" вариант f.

// В примере выше у функции только один аргумент, но delay должна быть универсальной: передавать любое количество 
// аргументов и контекст this.

function f(x) {
    console.log(x);
}

function delay(f, ms) {
    return function() {
        //попідглядав трохи в кривенькі коди в коментах.
        //прокоментуй тут  
        setTimeout(f.bind(f, [].slice.call(arguments)), ms);


    }
}

//не працює затримка хоча виводить те що треба
var f1000 = delay(f, 10000);
var f1500 = delay(f, 15000);

f1000("тест"); // выведет "тест" через 1000 миллисекунд
f1500("тест2"); // выведет "тест2" через 1500 миллисекунд

______________________________________________________________________

Вызов не чаще чем в N миллисекунд
// важность: 5
// Напишите функцию debounce(f, ms), которая возвращает обёртку, которая откладывает вызов f на ms миллисекунд.

// «Лишние» вызовы перезаписывают предыдущие отложенные задания. Все аргументы и контекст – передаются.

//Упрощённо можно сказать, что debounce возвращает вариант f, срабатывающий не чаще чем раз в ms миллисекунд.

function fi() {
    console.log("!!!");
}

function debounce(func, time) {
    var timer;
    return function() {
        if (timer) clearTimeout(timer);
        timer = setTimeout(f.bind(this), arguments);
    }
}

let f = debounce(fi, 1000);

f(1); // вызов отложен на 1000 мс
f(2); // предыдущий отложенный вызов игнорируется, текущий (2) откладывается на 1000 мс

// через 1 секунду будет выполнен вызов f(1)

setTimeout(function() { f(3) }, 1100); // через 1100 мс отложим вызов еще на 1000 мс
setTimeout(function() { f(4) }, 1200); // игнорируем вызов (3)

// через 2200 мс от начала выполнения будет выполнен вызов f(4)

//взагалі то їхня реалізація не проацює, виводить помилку
//SyntaxError: Identifier 'f' has already been declared 

______________________________________________________________________

Тормозилка
важность: 5
Напишите функцию throttle(f, ms)–« тормозилку», которая возвращает обёртку, передающую вызов f не чаще,
    чем раз в ms миллисекунд.
У этой функции должно быть важное существенное отличие от debounce: если игнорируемый вызов оказался последним,
    т.е.после него до окончания задержки ничего нет– то он выполнится.
Чтобы лучше понять, откуда взялось это требование, и как throttle должна работать– разберём реальное
применение, на которое и ориентирована эта задача.

Например, нужно обрабатывать передвижения мыши.
В JavaScript это делается функцией, которая будет запускаться при каждом микро - передвижении мыши и
получать координаты курсора.По мере того, как мышь двигается, эта функция может запускаться очень часто,
    может быть 100 раз в секунду(каждые 10 мс).

Функция обработки передвижения должна обновлять некую информацию на странице.
При этом обновление– слишком« тяжёлый» процесс, чтобы делать его при каждом микро - передвижении.
Имеет смысл делать его раз в 100 мс, не чаще.
Пусть функция, которая осуществляет это обновление по передвижению, называется onmousemove.
Вызов throttle(onmousemove, 100), по сути, предназначен для того, чтобы« притормаживать» обработку onmousemove.Технически, он должен возвращать обёртку, которая передаёт все вызовы onmousemove, но не чаще чем раз в 100 мс.

При этом промежуточные движения можно игнорировать, но мышь в конце концов где - то остановится.И это
последнее, итоговое положение мыши обязательно нужно обработать!

    Визуально это даст следующую картину обработки перемещений мыши:

    Первое обновление произойдёт сразу(это важно, посетитель тут же видит реакцию на своё действие).
Дальше может быть много вызовов(микро - передвижений) с разными координатами, но пока не пройдёт 100 мс– ничего
е будет.
По истечении 100 мс– опять обновление, с последними координатами.Промежуточные микро - передвижения
игнорированы.
В конце концов мышь где - то остановится, обновление по окончании очередной паузы 100 мс сработает с
последними координатами.
Ещё раз заметим– задача из реальной жизни, и в ней принципиально важно, что последнее передвижение
обрабатывается.Пользователь должен увидеть, где остановил мышь.


var f = function(a) {
    console.log(a)
};
//взята з коментів. тести проходить
function throttle(f, ms) {
    var bTimer = false,
        saveThis,
        saveArgs;

    return function() { //тут визивається при передаванні ззовні аргументів???
        //зберігаємо контекст???
        saveThis = this,
            //зберігаємо arguments??взагалі нащо це робити, коли ми не збираємося вставляти arguments в 
            //звичайний масив???
            saveArgs = arguments;
        //варіант коли таймер не встановлений тобто перший раз
        if (!bTimer) { /* таймер не установлен, 1-й вызов */
            //виклик toGo (припустим рухи були і в умову не ввійде)

            fGo();
        }
        //переходимо сюди (наскільки знаю return перериває подальше виконання функції)
        //тобто тут має закфнчитись виконання???
        return;

        function fGo() {
            if (saveArgs === undefined) { /* движений не было - ничего не делаем*/
                bTimer = false;
                return;
            }
            //тут визиваєм f з аргументами даними при визові???
            f.apply(saveThis, saveArgs);
            //тут присвоюємо undefined для того, що якщо не буде більше рухів зайти в умову
            // if і закінчити
            saveArgs = undefined;
            //тут сама себе визиває fGo щоб затримати час(тільки не розумію коли є вихід з взаємного циклу)?????
            setTimeout(fGo, ms);
            //присвоєння true щоб дати зрозуміти що це не перший визов
            bTimer = true;
        }
    }
}


// затормозить функцию до одного раза в 1000 мс
var f1000 = throttle(f, 1000);

f1000(1); // выведет 1
f1000(2); // (тормозим, не прошло 1000 мс)
f1000(3); // (тормозим, не прошло 1000 мс)

// когда пройдёт 1000 мс...
// выведет 3, промежуточное значение 2 игнорируется
// Следующая функция возвращает true, если параметр age больше 18. В ином случае она
//  задаёт вопрос confirm и возвращает его результат.
function checkAge(age) {
    if (age > 18) {
        return true;
    } else {
        return confirm('Родители разрешили?');
    }
}
// Перепишите функцию, чтобы она делала то же самое, но без if, в одну строку. Сделайте два варианта функции checkAge:

// Используя оператор '?'
// Используя оператор ||

function checkAge(age) {
    if (age > 18) ?
        true : confirm('Родители разрешили?');
}
//піддивився
function checkAge(age) {
    return (age > 18) || confirm('Родители разрешили?');
}

// Задача «Hello World» для функций :)

// Напишите функцию min(a,b), которая возвращает меньшее из чисел a,b.

// Пример вызовов:


//? ? ? плутав синтаксис тернарного оператора(

function min(a, b) {
    return (a > b) ? b : a;
}

console.log(min(23, 42));

//Напишите функцию pow(x,n), которая возвращает x в степени n. Иначе говоря, умножает x на себя n 
//раз и возвращает результат.
// Создайте страницу, которая запрашивает x и n, а затем выводит результат pow(x,n).
// P.S. В этой задаче функция обязана поддерживать только натуральные значения n, т.е. целые от 1 и выше.

var x = prompt("Enter base!", "");
var n;

n = prompt("Enter pow!", "");
if (n < 1) {
    alert("Pow must be not negative");
} else {
    pow(x, n);
}

function pow(x, n) {
    var res = x;
    for (i = 1; i < n; i++) {
        res *= x;
        console.log(res);
    }
    return res;
}

Функциональные выражения

//функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.

//Напишите функцию sumTo(n), которая для данного n вычисляет сумму чисел от 1 до n
// Сделайте три варианта решения:

// С использованием цикла.
// Через рекурсию, т.к. sumTo(n) = n + sumTo(n-1) для n > 1.
// С использованием формулы для суммы арифметической прогрессии.
function sumTo(n) {
    if (n > 1) {
        return n = n + sumTo(n - 1);
    } else {
        return n;
    }
}

console.log(sumTo(100));
-- -- -- -- -- -- -- -- -- -- -- -- -- --

function sumTo(n) {
    var res = 0;
    for (var i = 1; i <= n; i++) {
        res = res + i;
    }
    return res;
}
console.log(sumTo(100));
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
//трикутне число n*(n+1)/2
function sumTo(n) {
    var res = n * (n + 1) / 2;
    return res;
}
console.log(sumTo(100));

// Факториа́л числа – это число, умноженное на «себя минус один», затем на «себя минус два» и так далее, 
// до единицы. Обозначается n!
//Задача – написать функцию factorial(n), которая возвращает факториал числа n!, используя рекурсивный вызов.
function factorial(n) {
    if (n > 1) {
        return n * factorial(n - 1);
    } else {
        return n;
    }
}
console.log(factorial(5));

//Напишите функцию fib(n), которая возвращает n-е число Фибоначчи.
?

?
? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
чому при вичислюванні fib(45 + ) комп дуже довго думає а при 77 взагалі зависає
я зробив це в дуже витратний спосіб ?
    після відкриття відповіді там зазначалось що браузер не справиться.тут згадалась "асимптотична 
нотація " з cs50. якщо можна її визначити в даному випадку, якою вона буде? мені здається що точно не квадрат)
і взагалі браузер міг справитися з fib(77) в якийсь період, якщо його б залишити щоб рахував, чи тут вже питання
до стеку ? (хоча при переповненні стеку браузер припиняє сам скріпт, наскільки я помітив) ?

    ?
    ?
    ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
    function fib(n) {
        if (n > 1) {
            return n = fib(n - 1) + fib(n - 2);
        } else {
            return n;
        }
    }

alert(fib(7));
//in loop
function fib(n) {
    var a = 1;
    b = 1;
    var c = 0;

    for (var i = 1; i < n; i++) {
        a = b;
        b = c;
        c = a + b;
    }
    return c;
}
alert(fib(7));

Named Function Expression
//var f = function sayHi(...){}
//Имя функционального выражения (sayHi) имеет особый смысл. Оно доступно только изнутри самой функции (f).
//Как правило, имя NFE используется для единственной цели – позволить изнутри функции вызвать саму себя.
//Внутреннее имя позволяет функции надёжно обращаться к самой себе, где бы она ни находилась.
//Обратим внимание, что с Function Declaration так поступить нельзя. Такое «специальное» внутреннее имя функции 
//задаётся только в синтаксисе Function Expression.
//(function g() { return 1; }); - example